# -*- coding: utf-8 -*-
"""A_Fast_Algorithm_for_Level_Set_Based_Optimization.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tENASILhubuUWtdwsUqgE5Ed9l4L494-

## A Fast Algorithm for Level Set Based Optimization

Based on the following paper:
Song, B., & Chan, T. (2002). A fast algorithm for level set based optimization. UCLA Cam Report, 2(68).
"""

# Import necessary packages
import numpy as np
import cv2
import matplotlib.pyplot as plt

# Prepare image
img = cv2.imread("img7.png")
img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # Convert image to black and white
img = 1 - img / 255 # Normalize image
(x, y) = img.shape # Get size of image
plt.imshow(img, interpolation='none')
plt.show()

# Initial contour
phi = np.zeros((x, y))
for i in range(x):
  for j in range(y):
    if abs((i - 32)**2 + (j - 32)**2) < 100:
      phi[i, j] = 1
    else:
      phi[i, j] = -1

# Initial values of m, n
# m: the number of pixels for phi = 1
# n: the number of pixels for phi = -1
(m, n) = (0, 0)
for i in range(x):
  for j in range(y):
    if phi[i, j] == 1:
      m = m + 1
    else:
      n = n + 1

# Initial values of c1, c2
# c1: average of phi = 1
# c2: average of phi = -1
(c1, c2) = (0, 0)
for i in range(x):
  for j in range(y):
    if phi[i, j] == 1:
      c1 = c1 + img[i, j]
    else:
      c2 = c2 + img[i, j]
c1 = c1 / m
c2 = c2 / n

def update_phi(phi, m, n, c1, c2):
  for i in range(x):
    for j in range(y):
      z = img[i, j]
      if phi[i, j] == 1:
        delta_F_12 = ((z - c2) ** 2) * n / (n + 1) - ((z - c1) ** 2) * m / (m - 1)
        if delta_F_12 < 0:
          phi[i, j] = -1
          m = m - 1
          n = n + 1
          c1 = c1 + (c1 - z) / m
          c2 = c2 - (c2 - z) / n
      else:
        delta_F_21 = ((z - c1) ** 2) * m / (m + 1) - ((z - c2) ** 2) * n / (n - 1)
        if delta_F_21 < 0:
          phi[i, j] = 1
          m = m + 1
          n = n - 1
          c1 = c1 - (c1 - z) / m
          c2 = c2 + (c2 - z) / n
  return phi, m, n, c1, c2

def compute_F(phi, c1, c2):
  F = 0
  for i in range(x):
    for j in range(y):
      z = img[i, j]
      if phi[i, j] == 1:
        F = F + (z - c1) ** 2
      else:
        F = F + (z - c2) ** 2
  return F

plt.imshow(np.heaviside(phi, 0.5), interpolation='none')
plt.show()
F = compute_F(phi, c1, c2)
while(1):
  phi, m, n, c1, c2 = update_phi(phi, m, n, c1, c2)
  new_F = compute_F(phi, c1, c2)
  if F != new_F:
    F = new_F
    plt.imshow(np.heaviside(phi, 0.5), interpolation='none')
    plt.show()
  else:
    break