# -*- coding: utf-8 -*-
"""Active_Contours_Without_Edge.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Znw32TmVbHtsSo1U2n7sni_ZilKq1klZ
"""

# Import necessary packages
import numpy as np
import cv2
from google.colab.patches import cv2_imshow
import matplotlib.pyplot as plt

# Function to compute c1, c2
def compute_cs(u, phi):
  (x, y) = u.shape
  [num1, denum1, num2, denum2] = [0, 0, 0, 0]
  for i in range(x):
    for j in range(y):
      num1 += u[i, j]*np.heaviside(phi[i, j], 0.5)
      denum1 += np.heaviside(phi[i, j], 0.5)
      num2 += u[i, j]*(1 - np.heaviside(phi[i, j], 0.5))
      denum2 += (1 - np.heaviside(phi[i, j], 0.5))
  c1 = num1 / denum1
  c2 = num2 / denum2
  return c1, c2

# Heaviside and delta function as defined in p270
def H(e, z):
  return 0.5*(1+2/np.pi*np.atan(z/e))

def delta(e, z):
  return 1/np.pi*(1/(1+(z*z/e*e)))

# delta^x_-, delta^x_+, delta^y_-, delta^y_+ as defined in p271
def dxm(phi, i, j):
  return phi[i, j] - phi[max(0, i - 1), j]
def dxp(phi, i, j):
  return phi[min(i + 1, phi.shape[0] - 1), j] - phi[i, j]
def dym(phi, i, j):
  return phi[i, j] - phi[i, max(0, j - 1)]
def dyp(phi, i, j):
  return phi[i, min(j + 1, phi.shape[0] - 1)] - phi[i, j]

# Updating phi as defined in p272
def update_phi(phi, u, dt, h, mu, nu, l1, l2):
  [c1, c2] = compute_cs(img, phi)
  [x, y] = phi.shape
  denum1 = np.zeros((x, y))
  denum2 = np.zeros((x, y))
  denum3 = np.zeros((x, y))
  denum4 = np.zeros((x, y))
  a = np.zeros((x, y))
  b = np.zeros((x, y))
  
  for i in range(x):
    for j in range(y):
      a[i, j] = dt*delta(h, phi[i, j])
      b[i, j] = -nu - l1*((u[i, j] - c1)**2) + l2*((u[i, j] - c2)**2)
      denum1[i, j] = np.sqrt(((dxp(phi, i, j)**2)/(h**2)) + (((phi[i, min(j + 1, y - 1)] - phi[i, max(j - 1, 0)])**2)/((2*h)**2)))
      denum2[i, j] = np.sqrt(((dxp(phi, max(i - 1, 0), j)**2)/(h**2)) + (((phi[max(i - 1, 0), min(j + 1, y - 1)] - phi[max(i - 1, 0), max(j - 1, 0)])**2)/((2*h)**2)))
      denum3[i, j] = np.sqrt(((dyp(phi, i, j)**2)/(h**2)) + (((phi[min(i + 1, x - 1), j] - phi[max(i - 1, 0), j])**2)/((2*h)**2)))
      denum4[i, j] = np.sqrt(((dyp(phi, i, max(j - 1, 0))**2)/(h**2)) + (((phi[min(i + 1, x - 1), max(j - 1, 0)] - phi[max(i - 1, 0), max(j - 1, 0)])**2)/((2*h)**2)))

  s = x*y
  A = np.zeros((s, s))
  B = np.zeros((s, 1))
  denum1_inv = np.zeros((x, y))
  denum2_inv = np.zeros((x, y))
  denum3_inv = np.zeros((x, y))
  denum4_inv = np.zeros((x, y))
  for i in range(x):
    for j in range(y):
      if denum1[i, j] == 0:
        denum1_inv[i, j] = 1000
      else:
        denum1_inv[i, j] = 1 / denum1[i, j]

      if denum2[i, j] == 0:
        denum2_inv[i, j] = 1000
      else:
        denum2_inv[i, j] = 1 / denum2[i, j]
      
      if denum3[i, j] == 0:
        denum3_inv[i, j] = 1000
      else:
        denum3_inv[i, j] = 1 / denum3[i, j]
      
      if denum4[i, j] == 0:
        denum4_inv[i, j] = 1000
      else:
        denum4_inv[i, j] = 1 / denum4[i, j]

  for i in range(x):
    for j in range(y):
      B[i*x + j] = a[i, j]*b[i, j] + phi[i, j]
      A[i*x + j, i*x + j] = 1 + mu/(h**2)*(denum1_inv[i, j] + denum2_inv[i, j] + denum3_inv[i, j] + denum4_inv[i,j])
      if i < (x - 1):
        A[i*x + j, (i + 1)*x + j] = -mu/(h**2)*a[i, j]*denum1_inv[i, j]
      if i > 0:
        A[i*x + j, (i - 1)*x + j] = -mu/(h**2)*a[i, j]*denum2_inv[i, j]
      if j < (y - 1):
        A[i*x + j, i*x + (j + 1)] = -mu/(h**2)*a[i, j]*denum3_inv[i, j]
      if j > 0:
        A[i*x + j, i*x + (j - 1)] = -mu/(h**2)*a[i, j]*denum4_inv[i, j]
  newphi = np.linalg.solve(A, B)
  newphi = newphi.reshape((x, y))
  return newphi

# Identifying points where phi is 0
def phi_to_contour(u):
  [x, y] = u.shape
  phi_contour = np.zeros((x, y))
  phi_heaviside = np.heaviside(u, 0.5)
  n = 0
  for i in range(x):
    for j in range(y):
      d1 = abs(phi_heaviside[i, j] - phi_heaviside[max(0, i - 1), j])
      d2 = abs(phi_heaviside[i, j] - phi_heaviside[min(i + 1, x - 1), j])
      d3 = abs(phi_heaviside[i, j] - phi_heaviside[i, max(0, j - 1)])
      d4 = abs(phi_heaviside[i, j] - phi_heaviside[i, min(j + 1, y - 1)])
      if (d1 + d2 + d3 + d4 > 1):
        phi_contour[i, j] = 1
      else:
        phi_contour[i, j] = 0
  return phi_contour

def plus(x):
  if x>0:
    return x
  else:
    return 0

def minus(x):
  if x>0:
    return 0
  else:
    return x

# Functions S and G required for initialization
# p153 of Sussman paper
def compute_s(phi, e):
  [x, y] = phi.shape
  s = np.zeros((x, y))
  for i in range(x):
    for j in range(y):
      s[i, j] = phi[i, j] / np.sqrt(phi[i, j]**2 + e**2)
  return s

def compute_g(phi, h):
  [x, y] = phi.shape
  a = np.zeros((x, y))
  b = np.zeros((x, y))
  c = np.zeros((x, y))
  d = np.zeros((x, y))
  g = np.zeros((x, y))
  for i in range(x):
    for j in range(y):
      a[i, j] = dxm(phi, i, j)/h
      b[i, j] = dxp(phi, i, j)/h
      c[i, j] = dym(phi, i, j)/h
      d[i, j] = dyp(phi, i, j)/h
      if phi[i, j] > 0:
        g[i, j] = np.sqrt(max(plus(a[i, j])**2, minus(b[i, j])**2) + max(plus(c[i, j])**2, minus(d[i, j])**2)) - 1
      elif phi[i, j] < 0:
        g[i, j] = np.sqrt(max(plus(b[i, j])**2, minus(a[i, j])**2) + max(plus(d[i, j])**2, minus(c[i, j])**2)) - 1
      else:
        g[i, j] = 0
  return g

# Reinitialization
# p154 of Sussman paper
def reinitialize(phi, h, e, dt, a):
  [x, y] = phi.shape
  s = compute_s(phi, e)
  g = compute_g(phi, h)
  new_phi = phi - (dt * np.multiply(s, g))
  while(1):
    g = compute_g(new_phi, h)
    temp = new_phi - (dt * np.multiply(s, g))
    m = 0
    sum = 0
    for i in range(x):
      for j in range(y):
        if np.abs(new_phi[i, j]) < a:
          m += 1
          sum += np.abs(temp[i, j] - new_phi[i, j])
    if sum / m < dt * (h**2):
      break
    else:
      new_phi = temp
  return new_phi

# Prepare image
img = cv2.imread("img1.jpg")
img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # Convert image to black and white
img = 1 - img / 255 # Normalize image
(x, y) = img.shape # Get size of image
plt.imshow(img, interpolation='none')
plt.show()

# Initialization
phi = np.zeros((x, y))
for i in range(x):
  for j in range(y):
    if abs((i - 32)**2 + (j - 32)**2) < 100:
      phi[i, j] = 1
    elif abs((i - 32)**2 + (j - 32)**2) < 110:
      phi[i, j] = 0
    else:
      phi[i, j] = -1
n = 0 # Initialize n

# Set parameters
# Parameters for update_phi
dt = 0.1
h = 1
mu = 1
nu = 0.1
l1 = 1
l2 = 1

# Parameters for reinitialize
e = h
a = 1.5

while n<10:
  phi_contour = phi_to_contour(phi)
  plt.imshow(np.heaviside(phi, 0.5), interpolation='none')
  plt.show()
  phi = update_phi(phi, img, dt, h, mu, nu, l1, l2)
  phi = reinitialize(phi, h, e, dt, a)
  n += 1